/*
 * fit.hpp
 *
 *  Created on: Mar 8, 2013
 *      Author: Thibaut Metivet
 */

#ifndef FIT_HPP_
#define FIT_HPP_

#include "models.hpp"
#include "fit_data.hpp"
#include "fit_utils.hpp"
#include "statistics.hpp"
#include "io_utils.hpp"
#include "Minuit2/FCNBase.h"
#include "Minuit2/FunctionMinimum.h"
#include "Minuit2/MnPrint.h"
#include "Minuit2/MnMigrad.h"
#include "Minuit2/MnScan.h"
#include "Minuit2/ScanMinimizer.h"
#include "Minuit2/MnPlot.h"
#include "Minuit2/MnUserParameters.h"
#include "Eigen/Dense"
#include <sstream>
#include <cmath>
#include <utility>

using namespace ROOT;
using namespace Minuit2;

namespace LQCDA {  
    
    template<class Fcn>
    class Fit
    {
    private:
	FitDataBase* _fitdata;
	FitModel* _model;
	std::vector<FunctionMinimum> _min;
	
    protected:
	bool _isComputed;
	const double InitError = 0.5;	
	
    public:
	Fit(FitDataBase* data, FitModel* model)
	    : _fitdata(data), _model(model),
	      _min(), _isComputed(false)
	    {
		// TODO : checks for coherence
	    }

	virtual void fit(const std::vector<double>& initPar, const std::vector<LimitBase*>& parLimits);
	virtual void fit() { fit(std::vector<double>(_model->nParams()), std::vector<LimitBase*>()); }

	void printParameters();

    private:
	virtual void fit_impl(const std::vector<double>& initPar, const std::vector<LimitBase*>& parLimits);
    };

    // Fit::fit() member function
    template<class Fcn>
    void Fit<Fcn>::fit(const std::vector<double>& initPar,
		       const std::vector<LimitBase*>& parLimits)
    {
	if(!_isComputed) {
	    fit_impl(initPar, parLimits);
	}
    }

    /* // Fit::fit_impl() member function
    template<class Fcn>
    void Fit<Fcn>::fit_impl(const std::vector<double>& initPar,
		       const std::vector<LimitBase*>& parLimits)
    {
	size_t nParModel = _model->nParams();
	int nxDim = _fitdata->nxDim();
	int nyDim = _fitdata->nyDim();
	int nData = _fitdata->nData();
	MnUserParameters init_par;
	
	if(initPar.size() != nParModel) {
	    throw OutOfRange("Fit::fit()", nParModel);
	}
	
	for(int p=0; p<nParModel; ++p) {
	    // Name for parameter p
	    std::string parName = _model->getParName(p);
	    if(parName == "") {
		std::ostringstream oss;
		oss<<"p"<<p;
		parName = oss.str();
	    }
	    // Add parameter p
	    init_par.Add(parName.c_str(), initPar[p], abs(initPar[p]) * InitError);

	    // Set optional limits on parameters
	    if(parLimits.size() == nParModel) {
		parLimits[p]->apply(init_par, p);
	    }
	    else if(parLimits.size() != 0) {
		throw OutOfRange("Fit::fit()", parLimits.size());
	    }
	}
	
	// Add "pseudo-parameters" to deal with cases of x-correlation in dimension k
	for(int k=0; k<nxDim; ++k) {
	    if(_fitdata->is_x_corr(k)) {
		for(int i=0; i<nData; ++i) {
		    // Name for parameter p
		    std::ostringstream oss;
		    oss<<"x"<<i<<k;
		    // Add parameter p
		    init_par.Add(oss.str().c_str(), _fitdata->x(i,k), abs(_fitdata->x(i,k)) * InitError);
		}
	    }
	}

	LQCDOut<<"\nFit dimensions :\n"
	       <<"nxDim = "<<nxDim<<'\n'
	       <<"nyDim = "<<nyDim<<'\n'
	       <<"nData = "<<nData<<'\n';
	LQCDOut<<"\nX-corr = "<<_fitdata->have_x_corr()<<'\n';
		
	// TODO Extend to support several minimizers

	Fcn F(_fitdata, _model);
	LQCDOut<<"\nMinimization function initialized!\n";
	
	// Pre-minimizer call
	MnMigrad Migrad1(F, init_par, 0);
	FunctionMinimum Min = Migrad1();
	LQCDOut<<"(MINUIT) Pre-minimizer call :\n"
	       << "--------------------------------------------------------"
	       << Min
	       << "--------------------------------------------------------"
	       << std::endl;
	
	// Minimizer call
	MnUserParameters pre_min_par = Min.UserParameters();
	MnMigrad Migrad2(F, pre_min_par, 2);
	Min = Migrad2();

	if(!Min.IsValid()) {
	    LQCDOut<<"Minuit Library reported that minimization result is not valid !\n";
	    throw MinimizationException();
	}
	else {
	    _isComputed = true;
	    _min = new FunctionMinimum(Min);
	}
	LQCDOut<<"(MINUIT) Minimizer call :\n"
	       << "--------------------------------------------------------"
	       << Min
	       << "--------------------------------------------------------"
	       << std::endl;

	// Scan around position
	std::vector<std::pair<double,double> > ScanRes;
	MnPlot Plot;

	MnScan Scanner(F, Min.UserParameters(), 2);
	LQCDOut<<"(MINUIT) Scan around last position :\n"
	       << "--------------------------------------------------------"
	       <<std::endl;
	for(int i=0; i<init_par.Params().size(); ++i) {
	    LQCDOut<<"Parameter p"<<i<<std::endl;
	    ScanRes = Scanner.Scan(i);
	    Plot(ScanRes);
	}
	LQCDOut<< "--------------------------------------------------------"
	       << std::endl;
    }*/


    template<class Fcn>
    void Fit<Fcn>::fit_impl(const std::vector<double>& initPar,
				const std::vector<LimitBase*>& parLimits)
    {
	size_t nParModel = _model->nParams();
	int nxDim = _fitdata->nxDim();
	int nyDim = _fitdata->nyDim();
	int nData = _fitdata->nData();
	MnUserParameters init_par;
	
	if(initPar.size() != nParModel) {
	    throw OutOfRange("Fit::fit()", nParModel);
	}
	
	for(int p=0; p<nParModel; ++p) {
	    // Name for parameter p
	    std::string parName = _model->getParName(p);
	    if(parName == "") {
		std::ostringstream oss;
		oss<<"p"<<p;
		parName = oss.str();
	    }
	    // Add parameter p
	    init_par.Add(parName.c_str(), initPar[p], abs(initPar[p]) * InitError);

	    // Set optional limits on parameters
	    if(parLimits.size() == nParModel) {
		parLimits[p]->apply(init_par, p);
	    }
	    else if(parLimits.size() != 0) {
		throw OutOfRange("Fit::fit()", parLimits.size());
	    }
	}
	
	// Add "pseudo-parameters" to deal with cases of x-correlation in dimension k
	for(int k=0; k<nxDim; ++k) {
	    if(_fitdata->is_x_corr(k)) {
		for(int i=0; i<nData; ++i) {
		    // Name for parameter p
		    std::ostringstream oss;
		    oss<<"x"<<i<<k;
		    // Add parameter p
		    init_par.Add(oss.str().c_str(), _fitdata->x(i,k), abs(_fitdata->x(i,k)) * InitError);
		}
	    }
	}

	LQCDOut<<"\nFit dimensions :\n"
	       <<"nxDim = "<<nxDim<<'\n'
	       <<"nyDim = "<<nyDim<<'\n'
	       <<"nData = "<<nData<<'\n';
	LQCDOut<<"\nX-corr = "<<_fitdata->have_x_corr()<<'\n';
		
	// TODO Extend to support several minimizers

        // Fit each resampled sample
	for(int sample=0; sample<_fitdata->nSample(); ++sample) {
	    _fitdata->setCurrentSample(sample);
	    Fcn F(_fitdata, _model);
	    LQCDOut<<"\nMinimization function initialized!\n";
	
	    // Pre-minimizer call
	    MnMigrad Migrad1(F, init_par, 0);
	    FunctionMinimum Min = Migrad1();
	    LQCDOut<<"(MINUIT) Pre-minimizer call :\n"
		   << "--------------------------------------------------------"
		   << Min
		   << "--------------------------------------------------------"
		   << std::endl;
	
	    // Minimizer call
	    MnUserParameters pre_min_par = Min.UserParameters();
	    MnMigrad Migrad2(F, pre_min_par, 2);
	    Min = Migrad2();

	    if(!Min.IsValid()) {
		LQCDOut<<"Minuit Library reported that minimization result is not valid !\n";
		throw MinimizationException();
	    }
	    else {
		_isComputed = true;
		_min.push_back(Min);
	    }
	    LQCDOut<<"(MINUIT) Minimizer call :\n"
		   << "--------------------------------------------------------"
		   << Min
		   << "--------------------------------------------------------"
		   << std::endl;

	    /*// Scan around position
	    std::vector<std::pair<double,double> > ScanRes;
	    MnPlot Plot;

	    MnScan Scanner(F, Min.UserParameters(), 2);
	    LQCDOut<<"(MINUIT) Scan around last position :\n"
		   << "--------------------------------------------------------"
		   <<std::endl;
	    for(int i=0; i<init_par.Params().size(); ++i) {
		LQCDOut<<"Parameter p"<<i<<std::endl;
		ScanRes = Scanner.Scan(i);
		Plot(ScanRes);
	    }
	    LQCDOut<< "--------------------------------------------------------"
	           << std::endl;
	    */
	}
    }

    template<class Fcn>
    void Fit<Fcn>::printParameters()
    {
	if(_isComputed) {
	    
	}
	else {
	    // LQCDOut.verbose()<<"\nFit results not computed !\n";
	}
    }

}	// namespace LQCDA


#endif /* FIT_HPP_ */
