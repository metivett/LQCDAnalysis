/*
 * fit.hpp
 *
 *  Created on: Mar 8, 2013
 *      Author: Thibaut Metivet
 */

#ifndef FIT_HPP_
#define FIT_HPP_

#include "models.hpp"
#include "statistics.hpp"
#include "Minuit2/FCNBase.h"
#include "Eigen/Dense"

using namespace ROOT;
using namespace Minuit2;

namespace LQCDA {

    class FitData
    {
    protected:
	std::vector<std::vector<double> > _m_data;	// data ("y-points") to be fitted
	std::vector<std::vector<double> > _m_x;	// "x-points" ie points s.t. we evalutate model(x,params)

	std::vector<bool> _is_x_corr, _is_y_corr, _is_xy_corr;

	friend class Chi2Base;
    public:
	// TODO
	FitData(const std::vector<std::vector<double> >& data,
		const std::vector<std::vector<double> >& x,
		const std::vector<bool>& y_corr =std::vector<bool>(),
		const std::vector<bool>& x_corr =std::vector<bool>(),
		const std::vector<bool>& xy_corr =std::vector<bool>())
	    : _m_data(data), _m_x(x), _is_x_corr(x_corr), _is_y_corr(y_corr),
	      _is_xy_corr(xy_corr) {}

	// Getters
	int nData() const { return _m_data.size(); }
	int nxDim() const { return _m_x[0].size(); }
	int xSize() const {
	    return nData() * nxDim();
	}
	int nyDim() const { return _m_data[0].size(); }
	int ySize() const {
	    return nData() * nyDim();
	}
	bool is_x_corr(size_t k) const {
	    if(_is_x_corr.size()==0)
		return false;
	    else
		return _is_x_corr[k];
	}
	bool have_x_corr() const {
	    if(_is_x_corr.size()==0)
		return false;
	    else
		return true;
	}
	bool is_y_corr(size_t k) const {
	    if(_is_y_corr.size()==0)
		return false;
	    else
		return _is_y_corr[k];
	}
	bool have_y_corr() const {
	    if(_is_y_corr.size()==0)
		return false;
	    else
		return true;
	}
    };

/*
 * class Chi2Base
 * Base class to fit data with given model through minimizing a chi-squared
 * function of the data and parameters.
 * To be used with a Minuit2 minimizer.
 */
    class Chi2Base : public FCNBase
    {
    protected:
	const FitData& _m_fitdata;	// data to be fitted
	const FitModel& _m_model;		// model used for the fit

	//Eigen::MatrixXd _m_C_yy, _m_C_xx, _m_C_xy;	// Covariance matrices
	Eigen::MatrixXd _m_C_inv_yy, _m_C_inv_xx, _m_C_inv_xy; // Inverse blocks of the covariance matrix
	
    public:
	Chi2Base(const FitData& data, const FitModel& model,
		 const Eigen::MatrixXd& C_yy,
		 const Eigen::MatrixXd& C_xx,
		 const Eigen::MatrixXd& C_xy)
	    : _m_data(data), _m_model(model)
	    {
		compute_C_inv(C_yy, C_xx, C_xy);
	    }

	virtual double up () { return 1.0; }
	virtual double operator() (const std::vector<double>& params);
    private:
	// Bloc inversion:
	// ( A B )-1   ( X      -XBD-1        )
	// ( C D )   = ( -D-1CX D-1+D-1CXBD-1 )
	// with X=(A-BD-1C)-1
	void compute_C_inv(const Eigen::MatrixXd& C_yy,
			   const Eigen::MatrixXd& C_xx,
			   const Eigen::MatrixXd& C_xy)
	    {
		_m_C_inv_yy.noalias() = C_yy.inverse();
		if(C_xy.isZero()) {
		    _m_C_inv_xx.noalias() = C_xx.inverse();
		    _m_C_inv_xy.noalias() = Eigen::MatrixXd::Zero(C_xy.rows(), C_xy.cols());
		}
		else {
		    _m_C_inv_xx.noalias() = (C_xx - C_xy * _m_C_inv_yy * C_xy.transpose()).inverse();
		    _m_C_inv_xy.noalias() = - _m_C_inv_xx * C_xy * _m_C_inv_yy;
		}
		
	    }
    };

    
    double Chi2Base::operator() (const std::vector<double>& params)
    {
	double res(0);

	size_t nData = _m_fitdata.nData();
	size_t ySize = _m_fitdata.ySize();
	size_t nyDim = _m_fitdata.nyDim();
	
	// Compute Y and X in case of correlated "x data" and process by blocks
	if(_m_fitdata.have_x_corr())
	{
	    
	}
	// Else compute only Y and process by blocks
	else
	{
	    Eigen::VectorXd Y(ySize);
	    for(int k=0; k<nyDim; ++k)	    
	    {
		for(int i=0; i<nData; ++i)
		{
		    Y<<(_m_model.eval(k, _m_fitdata._m_x[i], params) - _m_fitdata._m_data[i][k]);
		}
	    }
	    res = Y.transpose() * _m_C_inv_yy * Y;
	}
	
	return res;
    }

}	// namespace LQCDA


#endif /* FIT_HPP_ */
